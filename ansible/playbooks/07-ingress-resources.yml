# Ingress 리소스 생성 (ALB 자동 생성)
# Domain-based Ingress (각 도메인별 네임스페이스)
---
- name: "도메인별 API Ingress 파일 확인"
  stat:
    path: "{{ playbook_dir }}/../../k8s/ingress/domain-based-api-ingress.yaml"
  register: domain_ingress_file
  delegate_to: localhost
  become: false

- name: "도메인별 API Ingress 적용 (ACM 인증서 있는 경우)"
  shell: |
    # ACM 인증서 ARN을 동적으로 치환
    sed "s|arn:aws:acm:ap-northeast-2:ACCOUNT_ID:certificate/CERT_ID|{{ acm_certificate_arn }}|g" \
      {{ playbook_dir }}/../../k8s/ingress/domain-based-api-ingress.yaml | \
      kubectl apply -f -
  register: domain_ingress_apply
  when: domain_ingress_file.stat.exists and acm_certificate_arn is defined and acm_certificate_arn != ""
  delegate_to: localhost
  become: false

- name: "도메인별 API Ingress 적용 (ACM 인증서 없을 경우 - 경고)"
  shell: |
    kubectl apply -f {{ playbook_dir }}/../../k8s/ingress/domain-based-api-ingress.yaml
  register: domain_ingress_apply_no_cert
  when: domain_ingress_file.stat.exists and (acm_certificate_arn is not defined or acm_certificate_arn == "")
  delegate_to: localhost
  become: false

- name: "인프라 서비스 Ingress 파일 확인 (Atlantis, Grafana, ArgoCD, Prometheus)"
  stat:
    path: "{{ playbook_dir }}/../../k8s/ingress/infrastructure-ingress.yaml"
  register: infra_ingress_file
  delegate_to: localhost
  become: false

- name: "인프라 서비스 Ingress 적용"
  shell: |
    sed "s|arn:aws:acm:ap-northeast-2:ACCOUNT_ID:certificate/CERT_ID|{{ acm_certificate_arn }}|g" \
      {{ playbook_dir }}/../../k8s/ingress/infrastructure-ingress.yaml | \
      kubectl apply -f -
  register: infra_ingress_apply
  when: infra_ingress_file.stat.exists and acm_certificate_arn is defined and acm_certificate_arn != ""
  delegate_to: localhost
  become: false

- name: "Fallback: 기존 방식 Ingress 생성 (파일이 없는 경우)"
  when: not domain_ingress_file.stat.exists
  block:
    - name: "ArgoCD ConfigMap 설정 (insecure 모드 - ALB에서 HTTPS 종료)"
      shell: |
        kubectl patch configmap -n argocd argocd-cmd-params-cm --type merge -p '{"data":{"server.insecure":"true"}}' 2>/dev/null || \
        kubectl create configmap -n argocd argocd-cmd-params-cm --from-literal=server.insecure=true --dry-run=client -o yaml | kubectl apply -f -
      register: argocd_configmap
      when: domain_name != "" and domain_name is defined

    - name: "ArgoCD Server 재시작 (ConfigMap 변경 적용)"
      shell: |
        kubectl rollout restart deployment -n argocd argocd-server
        kubectl rollout status deployment -n argocd argocd-server --timeout=120s
      when: argocd_configmap is defined and argocd_configmap.changed

    - name: "ArgoCD Ingress 생성 (/argocd)"
      shell: |
        # ArgoCD Service를 NodePort로 변경 (ALB target-type: instance 필수)
        kubectl patch svc argocd-server -n argocd -p '{"spec":{"type":"NodePort"}}'
        
        kubectl apply -f - <<EOF
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: argocd-ingress
      namespace: argocd
      annotations:
        alb.ingress.kubernetes.io/scheme: internet-facing
        alb.ingress.kubernetes.io/target-type: instance
        alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS": 443}]'
        alb.ingress.kubernetes.io/certificate-arn: {{ acm_certificate_arn }}
        alb.ingress.kubernetes.io/group.name: ecoeco-main
        alb.ingress.kubernetes.io/group.order: '20'
        alb.ingress.kubernetes.io/backend-protocol: HTTP
        alb.ingress.kubernetes.io/healthcheck-protocol: HTTP
        alb.ingress.kubernetes.io/healthcheck-path: /healthz
        alb.ingress.kubernetes.io/healthcheck-interval-seconds: '15'
        alb.ingress.kubernetes.io/healthcheck-timeout-seconds: '5'
        alb.ingress.kubernetes.io/healthy-threshold-count: '2'
        alb.ingress.kubernetes.io/unhealthy-threshold-count: '2'
    spec:
      ingressClassName: alb
      rules:
      - host: argocd.{{ domain_name }}
        http:
          paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: argocd-server
                port:
                  number: 80
      EOF
      register: argocd_ingress
      when: domain_name != "" and domain_name is defined

    - name: "Monitoring Ingress 생성 (/grafana)"
      shell: |
        # Grafana Service를 NodePort로 변경 (ALB target-type: instance 필수)
        kubectl patch svc prometheus-grafana -n monitoring -p '{"spec":{"type":"NodePort"}}'
        
        kubectl apply -f - <<EOF
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: grafana-ingress
      namespace: monitoring
      annotations:
        alb.ingress.kubernetes.io/scheme: internet-facing
        alb.ingress.kubernetes.io/target-type: instance
        alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS": 443}]'
        alb.ingress.kubernetes.io/certificate-arn: {{ acm_certificate_arn }}
        alb.ingress.kubernetes.io/group.name: ecoeco-main
        alb.ingress.kubernetes.io/group.order: '30'
        alb.ingress.kubernetes.io/backend-protocol: HTTP
        alb.ingress.kubernetes.io/healthcheck-path: /api/health
        alb.ingress.kubernetes.io/healthcheck-interval-seconds: '15'
        alb.ingress.kubernetes.io/healthcheck-timeout-seconds: '5'
        alb.ingress.kubernetes.io/healthy-threshold-count: '2'
        alb.ingress.kubernetes.io/unhealthy-threshold-count: '2'
    spec:
      ingressClassName: alb
      rules:
      - host: grafana.{{ domain_name }}
        http:
          paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: prometheus-grafana
                port:
                  number: 80
      EOF
      register: grafana_ingress
      when: domain_name != "" and domain_name is defined

    - name: "Default Backend Deployment 생성"
      shell: |
        kubectl apply -f - <<EOF
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: default-backend
      namespace: default
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: default-backend
      template:
        metadata:
          labels:
            app: default-backend
        spec:
          containers:
          - name: backend
            image: gcr.io/google_containers/defaultbackend-amd64:1.5
            ports:
            - containerPort: 8080
    ---
    apiVersion: v1
    kind: Service
    metadata:
      name: default-backend
      namespace: default
    spec:
      type: NodePort
      selector:
        app: default-backend
      ports:
      - port: 80
        targetPort: 8080
      EOF
      register: default_backend
      when: domain_name != "" and domain_name is defined

    - name: "API Services Ingress 생성 (default namespace)"
      shell: |
        kubectl apply -f - <<EOF
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: api-ingress
      namespace: default
      annotations:
        alb.ingress.kubernetes.io/scheme: internet-facing
        alb.ingress.kubernetes.io/target-type: instance
        alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS": 443}]'
        alb.ingress.kubernetes.io/certificate-arn: {{ acm_certificate_arn }}
        alb.ingress.kubernetes.io/group.name: ecoeco-main
        alb.ingress.kubernetes.io/group.order: '10'
        alb.ingress.kubernetes.io/backend-protocol: HTTP
        alb.ingress.kubernetes.io/healthcheck-path: /health
        alb.ingress.kubernetes.io/healthcheck-interval-seconds: '15'
        alb.ingress.kubernetes.io/healthcheck-timeout-seconds: '5'
        alb.ingress.kubernetes.io/healthy-threshold-count: '2'
        alb.ingress.kubernetes.io/unhealthy-threshold-count: '2'
        alb.ingress.kubernetes.io/success-codes: '200,404'
    spec:
      ingressClassName: alb
      rules:
      - host: api.{{ domain_name }}
        http:
          paths:
          # Phase 1: Core APIs
          - path: /api/v1/auth
            pathType: Prefix
            backend:
              service:
                name: auth-api
                port:
                  number: 8000
          
          - path: /api/v1/my
            pathType: Prefix
            backend:
              service:
                name: my-api
                port:
                  number: 8000
          
          - path: /api/v1/scan
            pathType: Prefix
            backend:
              service:
                name: scan-api
                port:
                  number: 8000
          
          # Phase 2: Extended APIs
          - path: /api/v1/character
            pathType: Prefix
            backend:
              service:
                name: character-api
                port:
                  number: 8000
          
          - path: /api/v1/location
            pathType: Prefix
            backend:
              service:
                name: location-api
                port:
                  number: 8000
          
          # Phase 3: Advanced APIs
          - path: /api/v1/info
            pathType: Prefix
            backend:
              service:
                name: info-api
                port:
                  number: 8000
          
          - path: /api/v1/chat
            pathType: Prefix
            backend:
              service:
                name: chat-api
                port:
                  number: 8000
          
          # Health Check
          - path: /health
            pathType: Exact
            backend:
              service:
                name: auth-api
                port:
                  number: 8000
      EOF
      register: api_ingress
      when: domain_name != "" and domain_name is defined

- name: Ingress 리소스 확인
  command: kubectl get ingress -A
  register: ingress_list
  changed_when: false

- name: Ingress 정보 출력
  debug:
    msg:
      - "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      - "✅ Ingress 리소스 생성 완료"
      - "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      - "{{ ingress_list.stdout_lines }}"
      - ""
      - "⚠️ 주의사항:"
      - "1. ALB 생성까지 3-5분 소요"
      - "2. DNS 전파까지 추가 시간 필요"
      - "3. 실제 서비스 배포 전까지 default-backend 응답"
      - ""
      - "ALB DNS 확인:"
      - "  kubectl get ingress argocd-ingress -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'"
      - ""
      - "Route53 설정:"
      - "  1. ALB DNS 복사"
      - "  2. Route53 → {{ domain_name }} → Alias 레코드"
      - "  3. Target: ALB DNS"
      - ""
      - "접속:"
      - "  https://{{ domain_name }}/argocd"
      - "  https://{{ domain_name }}/grafana (Monitoring 설치 후)"
      - "  https://{{ domain_name }}/api/v1/* (서비스 배포 후)"
