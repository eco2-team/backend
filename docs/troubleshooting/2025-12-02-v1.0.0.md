# Troubleshooting Log (v0.9.0 → v1.0.0)

이 문서는 v0.9.0에서 v1.0.0으로 이동하면서 재현·해결했던 대표 이슈를 정리한 자료입니다. 모든 사례는 `main` 반영 전에 develop 브랜치에서 검증되었으며, Scan/Chat 파이프라인이 동일한 Waste Pipeline을 사용하게 되면서 발생한 문제들입니다.

---

## 1. Chat 이미지 요청이 항상 Fallback 문구를 반환
- **증상**  
  - `/api/v1/chat/messages`에 `image_url`을 포함해 호출하면 `ChatService` 로그에 `Pipeline execution failed; using fallback answer.`가 출력되고, 사용자에게 “이미지가 인식되지 않았어요! 다시 시도해주세요.”만 응답.
  - Grafana의 `rest_client_request_duration_seconds`에 외부 호출이 기록되지 않음.
- **원인**  
  - 프론트엔드에서 만료되었거나 권한이 없는 이미지 URL을 전달해 Vision 단계에서 403/404가 발생했지만, Chat 서비스는 모든 예외를 동일한 fallback 경로로 처리해 원인을 즉시 파악하기 어려웠음.
- **해결**  
  1. Postman으로 동일한 `image_url`을 사용해 API를 호출해 재현하고, presigned URL 만료/권한 문제임을 확인.  
  2. 프론트엔드에서 업로드 직후 유효한 URL을 전달하도록 수정(필요 시 presigned 재요청).  
  3. 서버 로그에 URL과 상태 코드를 남기고, fallback 문구를 “이미지가 인식되지 않았어요! 다시 시도해주세요.”처럼 친절한 재시도 안내로 업데이트.  
  4. 장기적으로 Vision 오류 타입별 메시지를 구분해 사용자·개발자 모두 원인을 빠르게 파악할 수 있도록 개선 계획 수립.
- **관련 커밋/파일**  
  - `domains/chat/services/chat.py` (`_run_image_pipeline`, `_fallback_answer`)  
  - 프론트엔드 presigned URL 발급·전달 로직

---

## 2. Chat pytest 실패 (`test_render_answer_falls_back_when_missing`)
- **증상**  
  - GitHub Actions 또는 로컬에서 `pytest domains/chat/tests/test_chat_service.py` 실행 시  
    ```
    AssertionError: assert '원문 질문' in '이미지가 인식되지 않았어요! 다시 시도해주세요.'
    ```
- **원인**  
  - Redis/세션 의존성을 제거하는 과정에서 `ChatService._fallback_answer()` 문구를 변경했지만, 테스트는 여전히 질문 문자열이 포함된 이전 fallback을 기대함.
- **해결**  
  - 테스트를 fallback 문자열과 동기화하도록 수정.  
    ```python
    text = service._render_answer(result, "원문 질문")
    assert text == service._fallback_answer("원문 질문")
    ```
  - 변경 후 `PYTHONPATH=. pytest domains/chat/tests/test_chat_service.py`를 통해 회귀 테스트 진행.
- **관련 커밋/파일**  
  - `domains/chat/tests/test_chat_service.py` (`test_render_answer_falls_back_when_missing`)  
  - `domains/chat/services/chat.py` (`_fallback_answer`)

---

## 3. Waste Pipeline Prompt/Tag 변경 후 Scan·Chat 이미지가 이전 버전으로 응답
- **증상**  
  - Prompt/상황 태그를 수정한 뒤에도 Scan/Chat에서 예전 답변이 계속 반환되고, ArgoCD는 Sync 상태로 표시됨.
- **원인**  
  - `_shared/waste_pipeline`은 모듈형 파이썬 패키지라 문서 파일 업데이트만으로는 CI가 대상 도커 이미지를 재빌드하지 않음.
- **해결**  
  1. 프롬프트/태그 수정 시 README에 Waste Pipeline 변경 사항을 기록하고, CI 트리거용 커밋을 만들어 Scan/Chat 이미지를 재패키징.  
  2. `domains/_shared/waste_pipeline/README.md`에 파이프라인 구조 및 변경 로그를 추가해 운영 히스토리를 남김.  
  3. develop → main 머지 시 README의 “Troubleshooting” 섹션을 최신 사례로 유지해 릴리스 노트와 연동.
- **관련 커밋/파일**  
  - `domains/_shared/waste_pipeline/data/{prompts,situation_tags}.txt`  
  - `domains/_shared/waste_pipeline/README.md`  
  - `README.md` (Troubleshooting 섹션 링크)

---

## 4. 릴리스 테스트 중 Scan/Chat CI 트리거 회피
- **증상**  
  - v1.0.0 준비 과정에서 waste pipeline을 되돌린 뒤 CI가 다시 돌지 않아 Scan/Chat 이미지가 v0.9.0 기준으로 남음.
- **원인**  
  - `git revert` 이후 추가 커밋 없이 develop을 main에 머지하면 ci-services.yml이 실행되지 않음.
- **해결**  
  - README 또는 Docs에 경미한 갱신(예: Waste Pipeline README 작성, Troubleshooting log 업데이트)을 추가 커밋으로 만들어 Scan/Chat CI를 의도적으로 트리거.  
  - 필요 시 `gh workflow run ci-services.yml -f target_services=scan,chat`으로 수동 재실행.
- **관련 커밋/파일**  
  - `docs/troubleshooting/2025-12-02-v1.0.0.md` (본 문서)  
  - `ci/ci-services.yml`

---

## 5. Chat 세션 저장소 제거로 Classification 파이프라인 복구
- **증상**  
  - Chat API가 요청을 받을 때마다 Redis/PostgreSQL에서 세션 이력을 조회하고 저장하느라 Vision/Text Classification 호출이 늦게 시작되거나 아예 실행되지 않았음.  
  - 프런트엔드가 `session_id`를 누락하거나 만료된 세션을 전달하면 `ChatService`가 history fetch 단계에서 예외를 내고 즉시 fallback으로 빠짐.  
  - `chat_sessions`, `chat_messages` 테이블과 Redis 리스트에 잔존 데이터가 쌓이며 Storage IO와 연결 수가 급증.
- **원인**  
  - 챗봇 history를 Redis + Postgres에 동시에 기록하도록 설계했지만, 이미지/텍스트 분류 파이프라인은 stateless하게 동작하므로 세션 보존이 불필요했음.  
  - 세션 저장 로직이 Vision/Text 파이프라인보다 먼저 실행돼 장애 지점이 늘어났고, history fetch 실패가 Classification 단계로 전파됨.  
  - 저장된 history에 이전 분류 결과(`assistant_summary`, `user_answer`)가 그대로 남아 이후 OpenAI 호출에 재삽입되면서 AI 팀이 전달한 최신 Classification 출력이 오염되는 문제가 추가로 발견됨.
- **해결**  
  1. `refactor(chat): drop session and memory store` 커밋(68d72f6)에서 `ChatSessionStore`, `chat_sessions`, `chat_messages` 등을 제거해 Chat API를 완전 stateless하게 변경.  
  2. `_build_messages()`를 system + 현재 질문만 포함하도록 단순화해 과거 응답이 prompt에 재삽입되지 않게 차단.  
  3. `/api/v1/images/chat` 메타데이터에서 `chat_session_id` 의존을 없애고, 메시지 ID만으로 Vision 파이프라인을 호출하도록 front ↔ back 규약을 정비.  
  4. 이미 생성된 세션 테이블은 `DROP TABLE IF EXISTS chat_sessions, chat_messages;`로 정리하고, Redis 키(`chat:session:*`)는 `redis-cli keys`/`del`로 삭제.  
  5. 배포 후 `PYTHONPATH=. pytest domains/chat/tests/test_chat_service.py`로 회귀 테스트를 돌리고, Grafana에서 Chat 응답 딜레이 및 잘못된 분류 응답 비율이 감소했음을 확인.
- **관련 커밋/파일**  
  - `domains/chat/services/chat.py`, `domains/chat/services/session_store.py`  
  - `docs/data/database-architecture.md`, `docs/development/guides/fastapi/IMAGE_UPLOAD_CHAT_FLOW.md`

---

## 6. Auth OAuth 콜백이 프런트로 리다이렉트되지 않음
- **증상**  
  - Google/Kakao/Naver OAuth 성공 시 API 응답 본문(JSON)만 표시되고 SPA `/login` 화면에서 멈춤.  
  - 쿠키는 발급되지만 프런트가 리다이렉트되지 않아 사용자 입장에서는 로그인에 실패한 것처럼 보임.
- **원인**  
  - 콜백 핸들러가 고정된 `success_url`만 반환해 프록시가 전달한 `x-forwarded-*` 헤더나 프런트 도메인을 반영하지 못함.  
  - `x-frontend-origin` 헤더 부재 시 HTTPS/도메인 변환이 어긋나 Vercel/Prod 등 다중 프런트에서 URL이 깨짐.
- **해결**  
  1. `fix(auth): Redirect to frontend after successful OAuth login` 커밋(5846944)에서 `_build_frontend_redirect_url()`을 도입해 실제 프런트 오리진을 계산.  
  2. OAuth state에 저장된 `frontend_origin`을 fallback으로 활용하고, 성공 시 홈(`/#/home`), 실패 시 `settings.oauth_failure_redirect_url`로 Location 헤더를 설정.  
  3. 쿠키 도메인을 `.growbin.app`으로 통일해 리다이렉트 후에도 세션이 유지되도록 조정.  
  4. 배포 후 브라우저/모바일에서 Google·Kakao·Naver 플로우를 재검증해 JSON 응답 노출이 사라짐을 확인.
- **관련 커밋/파일**  
  - `domains/auth/api/v1/endpoints/auth.py`  
  - `docs/development/guides/updates/TODAY_CHANGES.md`

---

## 7. OAuth Provider HTTPS egress 차단
- **증상**  
  - Auth Pod에서 Kakao/Google/Naver OAuth 엔드포인트 호출 시 `ClientConnectorError` 또는 `SSL handshake failed`가 발생해 Authorization URL 생성부터 실패.  
  - `kubectl logs -n auth deployment/auth-api`에서 재시도 로그가 쌓이고, 사용자는 OAuth 버튼을 눌러도 즉시 에러를 받음.
- **원인**  
  - 초기 NetworkPolicy가 kube-dns만 허용하고 외부 443 egress를 막아 OAuth Provider, GitHub, S3 등 외부 서비스와의 통신이 모두 차단됨.  
  - Auth 네임스페이스뿐 아니라 이미지/챗/스캔 등 외부 AI API에 의존하는 서비스에도 동일한 제한이 적용됨.
- **해결**  
  1. `fix(network): Allow external HTTPS egress for OAuth providers` 커밋(fb696d8)에서 `allow-external-https` NetworkPolicy를 추가해 `sesacthon.io/domain in {auth,chat,scan,image}` 파드가 TCP 443으로 나갈 수 있게 함.  
  2. CIDR 대신 `0.0.0.0/0` + `ipBlock` 예외를 사용하고, 감사 목적의 NetworkPolicy 주석에 허용 사유를 기록.  
  3. 적용 후 `kubectl logs`에서 OAuth 요청이 200/302를 반환하고, Grafana 지표(`oauth_request_duration_seconds`)가 정상 범위를 회복.
- **관련 커밋/파일**  
  - `workloads/network-policies/*/allow-external-https.yaml`  
  - `docs/troubleshooting/TROUBLESHOOTING.md` (NetworkPolicy 섹션)

---

## 참고 명령어
```bash
# Chat/Scan 도커 이미지 태그 확인
kubectl get deploy -n chat chat-api -o jsonpath='{.spec.template.spec.containers[0].image}'
kubectl get deploy -n scan scan-api -o jsonpath='{.spec.template.spec.containers[0].image}'

# develop → main 동기화 후 README만 main 버전을 유지하는 절차
git checkout -b release/v1.0.0
git checkout origin/main -- README.md
git commit -m "chore(release): keep main README"
```

위 사례는 v1.0.0 릴리스 문서와 연계해 유지되며, 새로운 이슈는 README의 Troubleshooting 섹션에 링크를 추가합니다.

