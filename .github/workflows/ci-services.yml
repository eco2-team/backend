name: CI Services Quality Gate

on:
  push:
    branches:
      - main
      - develop
      - refactor/gitops-sync-wave
    paths:
      # FastAPI ÏÑúÎπÑÏä§Îßå (ext-authzÎäî GoÏù¥ÎØÄÎ°ú ci-ext-authz.ymlÏóêÏÑú Ï≤òÎ¶¨)
      - "domains/auth/**"
      - "domains/character/**"
      - "domains/chat/**"
      - "domains/image/**"
      - "domains/location/**"
      - "domains/my/**"
      - "domains/scan/**"
      - "domains/_shared/**"
      - "domains/_base/**"
      - "workloads/domains/auth/**"
      - "workloads/domains/character/**"
      - "workloads/domains/chat/**"
      - "workloads/domains/image/**"
      - "workloads/domains/location/**"
      - "workloads/domains/my/**"
      - "workloads/domains/scan/**"
      - "workloads/domains/character-worker/**"
      - "workloads/domains/scan-worker/**"
      - "workloads/domains/my-worker/**"
  pull_request:
    branches:
      - main
      - develop
      - refactor/gitops-sync-wave
    paths:
      # FastAPI ÏÑúÎπÑÏä§Îßå (ext-authzÎäî GoÏù¥ÎØÄÎ°ú ci-ext-authz.ymlÏóêÏÑú Ï≤òÎ¶¨)
      - "domains/auth/**"
      - "domains/character/**"
      - "domains/chat/**"
      - "domains/image/**"
      - "domains/location/**"
      - "domains/my/**"
      - "domains/scan/**"
      - "domains/_shared/**"
      - "domains/_base/**"
      - "workloads/domains/auth/**"
      - "workloads/domains/character/**"
      - "workloads/domains/chat/**"
      - "workloads/domains/image/**"
      - "workloads/domains/location/**"
      - "workloads/domains/my/**"
      - "workloads/domains/scan/**"
      - "workloads/domains/character-worker/**"
      - "workloads/domains/scan-worker/**"
      - "workloads/domains/my-worker/**"
  workflow_dispatch:
    inputs:
      force_all:
        description: "Î™®Îì† API ÏÑúÎπÑÏä§Î•º Í∞ïÏ†úÎ°ú ÎπåÎìú/Ìë∏Ïãú"
        type: boolean
        default: false
      target_services:
        description: "ÏΩ§ÎßàÎ°ú Íµ¨Î∂ÑÎêú ÏÑúÎπÑÏä§ Ïù¥Î¶Ñ Î™©Î°ù (Ïòà: auth,my)"
        required: false

permissions:
  contents: write
  packages: write

concurrency:
  group: ci-services-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  commit-filter:
    name: üõÇ Commit Filter
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.detect.outputs.skip }}
      reason: ${{ steps.detect.outputs.reason }}
      commit_type: ${{ steps.detect.outputs.commit_type }}
    steps:
      - name: Detect conventional commit type
        id: detect
        env:
          EVENT_NAME: ${{ github.event_name }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          set -euo pipefail
          if [ "${GITHUB_ACTOR}" = "github-actions[bot]" ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "reason=Triggered by github-actions bot (manifest bump)" >> "$GITHUB_OUTPUT"
            echo "commit_type=bot" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [ "$EVENT_NAME" = "pull_request" ]; then
            REF_TEXT="$PR_TITLE"
          else
            # Ï≤´ Î≤àÏß∏ Ï§ÑÎßå ÏÇ¨Ïö© (Î©ÄÌã∞ÎùºÏù∏ Ïª§Î∞ã Î©îÏãúÏßÄÏóêÏÑú Î≥∏Î¨∏ Ï†úÏô∏)
            # printf | head Ï°∞Ìï©ÏùÄ pipefail ÌôòÍ≤ΩÏóêÏÑú SIGPIPE ÏóêÎü¨ Î∞úÏÉù Í∞ÄÎä•
            REF_TEXT="${COMMIT_MSG%%$'\n'*}"
          fi
          REF_TEXT="${REF_TEXT:-none}"
          TYPE=$(printf '%s\n' "$REF_TEXT" | sed -n 's/^\([A-Za-z0-9_-]\+\):.*/\1/p' | tr '[:upper:]' '[:lower:]')
          if [[ "$TYPE" =~ ^(docs)$ ]]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "reason=Commit type '$TYPE' is configured to bypass service CI" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
            echo "reason=" >> "$GITHUB_OUTPUT"
          fi
          if [ -z "$TYPE" ]; then
            TYPE="unknown"
          fi
          echo "commit_type=$TYPE" >> "$GITHUB_OUTPUT"

  skip-notice:
    name: ‚è≠Ô∏è CI Skipped
    needs: commit-filter
    if: needs.commit-filter.outputs.skip == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Publish skip summary
        run: |
          cat <<'EOF' >> "$GITHUB_STEP_SUMMARY"
          ## ‚è≠Ô∏è Service CI Skipped
          - Reason: ${{ needs.commit-filter.outputs.reason }}
          - Commit type: `${{ needs.commit-filter.outputs.commit_type }}`
          EOF

  detect-api-changes:
    name: üîç Detect API Changes
    runs-on: ubuntu-latest
    needs: commit-filter
    if: needs.commit-filter.outputs.skip != 'true'
    outputs:
      has_changes: ${{ steps.prepare.outputs.has_changes }}
      services: ${{ steps.prepare.outputs.services }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Changed files
        id: changes
        uses: tj-actions/changed-files@v45
        with:
          files: |
            domains/auth/**
            domains/character/**
            domains/chat/**
            domains/image/**
            domains/location/**
            domains/my/**
            domains/scan/**
            domains/_shared/waste_pipeline/**
            domains/_shared/celery/**
            workloads/domains/auth/**
            workloads/domains/character/**
            workloads/domains/chat/**
            workloads/domains/image/**
            workloads/domains/location/**
            workloads/domains/my/**
            workloads/domains/scan/**

      - name: Prepare service matrix
        id: prepare
        run: |
          python3 <<'PYEOF'
          import json
          import os
          import sys
          from collections import OrderedDict

          files = os.environ.get("CHANGED_FILES", "").split()
          any_changed = os.environ.get("ANY_CHANGED", "false").lower() == "true"
          event_name = os.environ.get("EVENT_NAME", "")
          force_all = os.environ.get("FORCE_ALL", "false").lower() == "true"
          
          # FastAPI ÏÑúÎπÑÏä§ Î™©Î°ù (Î™ÖÏãúÏ†Å ÎÇòÏó¥)
          # ext-authzÎäî Go ÌîÑÎ°úÏ†ùÌä∏Ïù¥ÎØÄÎ°ú Î≥ÑÎèÑ CI(ci-ext-authz.yml)ÏóêÏÑú Ï≤òÎ¶¨
          FASTAPI_SERVICES = [
              "auth",
              "character",
              "chat",
              "image",
              "location",
              "my",
              "scan",
          ]
          
          alias_map = {
              "info": "image",
          }
          shared_triggers = {
              "domains/_shared/waste_pipeline": ["chat", "scan"],
              "domains/_shared/celery": ["scan", "character"],
          }

          def normalize(service: str) -> str:
              return alias_map.get(service, service)

          raw_targets = [
              s.strip()
              for s in os.environ.get("TARGET_SERVICES", "").split(",")
              if s.strip()
          ]
          target_services = [normalize(s) for s in raw_targets]

          services = []
          all_services = sorted(FASTAPI_SERVICES)

          if event_name == "workflow_dispatch":
              if force_all:
                  services = all_services
              elif target_services:
                  invalid = [svc for svc in target_services if svc not in all_services]
                  if invalid:
                      sys.stderr.write(f"Unknown services: {', '.join(invalid)}\n")
                      sys.exit(1)
                  # preserve order
                  services = list(OrderedDict.fromkeys(target_services))

          if not services and any_changed:
              for path in files:
                  # shared Í≤ΩÎ°úÏóê ÎåÄÌïú Ìä∏Î¶¨Í±∞ (waste_pipeline Î≥ÄÍ≤Ω Ïãú chat, scan Ïû¨Î∞∞Ìè¨)
                  for prefix, svc_list in shared_triggers.items():
                      if path.startswith(prefix):
                          for svc in svc_list:
                              svc = normalize(svc)
                              if svc in all_services and svc not in services:
                                  services.append(svc)

                  parts = path.split("/")
                  # domains/<service>/ Í≤ΩÎ°ú Í∞êÏßÄ
                  if len(parts) >= 2 and parts[0] == "domains":
                      svc = normalize(parts[1])
                      if svc and svc in all_services and svc not in services:
                          services.append(svc)
                  # workloads/domains/<service>/ Í≤ΩÎ°ú Í∞êÏßÄ
                  elif len(parts) >= 3 and parts[0] == "workloads" and parts[1] == "domains":
                      svc = normalize(parts[2])
                      if svc and svc in all_services and svc not in services:
                          services.append(svc)

          with open(os.environ["GITHUB_OUTPUT"], "a") as out:
              if services:
                  out.write("has_changes=true\n")
                  out.write(f"services={json.dumps(services)}\n")
              else:
                  out.write("has_changes=false\n")
                  out.write("services=[]\n")
          PYEOF
        env:
          CHANGED_FILES: ${{ steps.changes.outputs.all_changed_files }}
          ANY_CHANGED: ${{ steps.changes.outputs.any_changed }}
          EVENT_NAME: ${{ github.event_name }}
          FORCE_ALL: ${{ github.event.inputs.force_all || 'false' }}
          TARGET_SERVICES: ${{ github.event.inputs.target_services || '' }}

  api-quality:
    name: üß™ API Lint & Test
    runs-on: ubuntu-latest
    needs:
      - commit-filter
      - detect-api-changes
    if: >
      needs.commit-filter.outputs.skip != 'true' &&
      needs.detect-api-changes.outputs.has_changes == 'true'
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.detect-api-changes.outputs.services) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install tooling
        run: |
          python -m pip install --upgrade pip
          pip install black==24.4.2 ruff==0.6.9 pytest==8.3.3 pytest-asyncio==0.24.0
          pip install -r domains/${{ matrix.service }}/requirements.txt

      - name: Black (format check)
        run: black --check domains/${{ matrix.service }}

      - name: Ruff lint
        run: ruff check domains/${{ matrix.service }}

      - name: Pytest
        working-directory: domains/${{ matrix.service }}
        env:
          PYTHONPATH: ${{ github.workspace }}/domains/${{ matrix.service }}
        run: pytest

  api-build-push:
    name: üì¶ Build & Push API Images
    runs-on: ubuntu-latest
    needs:
      - commit-filter
      - detect-api-changes
      - api-quality
    # PRÏóêÏÑúÎäî ÌÖåÏä§Ìä∏Îßå, Î®∏ÏßÄ(push) ÏãúÏóêÎßå ÎπåÎìú/Ìë∏Ïãú
    if: >
      github.event_name == 'push' &&
      needs.commit-filter.outputs.skip != 'true' &&
      needs.detect-api-changes.outputs.has_changes == 'true'
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        service: ${{ fromJson(needs.detect-api-changes.outputs.services) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Prepare image tags
        id: meta
        run: |
          set -euo pipefail
          SHORT_SHA=$(git rev-parse --short=6 HEAD)
          SERVICE="${{ matrix.service }}"
          IMAGE_REPO="docker.io/mng990/eco2"
          SERVICE_SLUG="${SERVICE}-api"
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            IS_PR=true
            BASE_REF="${{ github.event.pull_request.base.ref }}"
          else
            IS_PR=false
            BASE_REF="${GITHUB_REF##*/}"
          fi
          VERSION=$(cat VERSION)
          if [ "$BASE_REF" = "main" ] && [ "$IS_PR" = "false" ]; then
            UNIQUE_TAG="${SERVICE_SLUG}-${VERSION}-${SHORT_SHA}"
            {
              echo "tags<<TAGS"
              echo "${IMAGE_REPO}:${UNIQUE_TAG}"
              echo "${IMAGE_REPO}:${SERVICE_SLUG}-prod-latest"
              echo "${IMAGE_REPO}:${SERVICE_SLUG}-latest"
              echo "TAGS"
            } >> "$GITHUB_OUTPUT"
            echo "tag_name=${UNIQUE_TAG}" >> "$GITHUB_OUTPUT"
            echo "manifest_tag=${UNIQUE_TAG}" >> "$GITHUB_OUTPUT"
          else
            DEV_TAG="${SERVICE_SLUG}-dev-${SHORT_SHA}"
            DEV_LATEST_TAG="${SERVICE_SLUG}-dev-latest"
            {
              echo "tags<<TAGS"
              echo "${IMAGE_REPO}:${DEV_TAG}"
              echo "${IMAGE_REPO}:${DEV_LATEST_TAG}"
              echo "TAGS"
            } >> "$GITHUB_OUTPUT"
            echo "tag_name=${DEV_TAG}" >> "$GITHUB_OUTPUT"
            echo "manifest_tag=${DEV_LATEST_TAG}" >> "$GITHUB_OUTPUT"
          fi

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: domains/${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Sync manifest branch
        if: >
          (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
        env:
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          git fetch origin "${BRANCH_NAME}"
          git checkout -B "${BRANCH_NAME}"
          git pull --rebase origin "${BRANCH_NAME}"

      - name: Update dev manifest tag
        if: >
          github.ref == 'refs/heads/develop'
        id: update_dev
        env:
          KUSTOMIZE_FILE: workloads/domains/${{ matrix.service }}/dev/kustomization.yaml
          TAG_NAME: ${{ steps.meta.outputs.manifest_tag }}
        run: |
          python -m pip install --upgrade pip pyyaml
          python scripts/ci/update_kustomize_image.py \
            --file "$KUSTOMIZE_FILE" \
            --image docker.io/mng990/eco2 \
            --tag "$TAG_NAME"
          if git diff --quiet -- "$KUSTOMIZE_FILE"; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "file=$KUSTOMIZE_FILE" >> "$GITHUB_OUTPUT"
          fi

      - name: Update prod manifest tag
        if: >
          github.ref == 'refs/heads/main'
        id: update_prod
        env:
          KUSTOMIZE_FILE: workloads/domains/${{ matrix.service }}/prod/kustomization.yaml
          TAG_NAME: ${{ steps.meta.outputs.tag_name }}
        run: |
          python -m pip install --upgrade pip pyyaml
          python scripts/ci/update_kustomize_image.py \
            --file "$KUSTOMIZE_FILE" \
            --image docker.io/mng990/eco2 \
            --tag "$TAG_NAME"
          if git diff --quiet -- "$KUSTOMIZE_FILE"; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "file=$KUSTOMIZE_FILE" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit manifest updates
        if: >
          (steps.update_dev.outputs.changed == 'true') ||
          (steps.update_prod.outputs.changed == 'true')
        env:
          DEV_FILE: ${{ steps.update_dev.outputs.file }}
          PROD_FILE: ${{ steps.update_prod.outputs.file }}
          TAG_NAME: ${{ steps.meta.outputs.manifest_tag }}
          SERVICE: ${{ matrix.service }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if [ -n "${DEV_FILE}" ]; then git add "${DEV_FILE}"; fi
          if [ -n "${PROD_FILE}" ]; then git add "${PROD_FILE}"; fi
          git commit -m "chore(${SERVICE}): bump image tag to ${TAG_NAME} [skip ci]"
          git push origin HEAD:${GITHUB_REF_NAME}

  # ============================================================================
  # Base Image Build (Í≥µÌÜµ ÏùòÏ°¥ÏÑ±)
  # ============================================================================
  base-build-push:
    name: üèóÔ∏è Build & Push Base Image
    runs-on: ubuntu-latest
    needs:
      - commit-filter
      - detect-api-changes
    if: >
      github.event_name == 'push' &&
      needs.commit-filter.outputs.skip != 'true'
    steps:
      - name: Check for base changes
        id: check
        run: |
          # Base Ïù¥ÎØ∏ÏßÄ Î≥ÄÍ≤Ω Ïó¨Î∂Ä ÌôïÏù∏ (Í∞ÑÏÜåÌôîÎêú Î°úÏßÅ)
          echo "should_build=true" >> "$GITHUB_OUTPUT"

      - name: Checkout
        if: steps.check.outputs.should_build == 'true'
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        if: steps.check.outputs.should_build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: steps.check.outputs.should_build == 'true'
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Prepare base image tags
        if: steps.check.outputs.should_build == 'true'
        id: meta
        run: |
          IMAGE_REPO="docker.io/mng990/eco2"
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "tags=${IMAGE_REPO}:base-prod-latest,${IMAGE_REPO}:base-latest" >> "$GITHUB_OUTPUT"
          else
            echo "tags=${IMAGE_REPO}:base-dev-latest" >> "$GITHUB_OUTPUT"
          fi

      - name: Build and push base image
        if: steps.check.outputs.should_build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: domains/_base/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================================================
  # Worker Image Build (character-worker, scan-worker)
  # ============================================================================
  worker-build-push:
    name: üîß Build & Push Worker Images
    runs-on: ubuntu-latest
    needs:
      - commit-filter
      - detect-api-changes
      - api-quality
      - base-build-push
    if: >
      github.event_name == 'push' &&
      needs.commit-filter.outputs.skip != 'true' &&
      needs.detect-api-changes.outputs.has_changes == 'true'
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        worker: [character, scan, my]
    steps:
      - name: Check if worker should build
        id: check
        env:
          SERVICES: ${{ needs.detect-api-changes.outputs.services }}
          WORKER: ${{ matrix.worker }}
        run: |
          # Ìï¥Îãπ ÎèÑÎ©îÏù∏Ïù¥ Î≥ÄÍ≤ΩÎêòÏóàÏúºÎ©¥ WorkerÎèÑ ÎπåÎìú
          if echo "$SERVICES" | grep -q "\"$WORKER\""; then
            echo "should_build=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_build=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout
        if: steps.check.outputs.should_build == 'true'
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        if: steps.check.outputs.should_build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: steps.check.outputs.should_build == 'true'
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Prepare worker image tags
        if: steps.check.outputs.should_build == 'true'
        id: meta
        run: |
          set -euo pipefail
          SHORT_SHA=$(git rev-parse --short=6 HEAD)
          WORKER="${{ matrix.worker }}"
          IMAGE_REPO="docker.io/mng990/eco2"
          WORKER_SLUG="${WORKER}-worker"
          VERSION=$(cat VERSION)
          
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            UNIQUE_TAG="${WORKER_SLUG}-${VERSION}-${SHORT_SHA}"
            {
              echo "tags<<TAGS"
              echo "${IMAGE_REPO}:${UNIQUE_TAG}"
              echo "${IMAGE_REPO}:${WORKER_SLUG}-prod-latest"
              echo "${IMAGE_REPO}:${WORKER_SLUG}-latest"
              echo "TAGS"
            } >> "$GITHUB_OUTPUT"
            echo "manifest_tag=${UNIQUE_TAG}" >> "$GITHUB_OUTPUT"
          else
            DEV_TAG="${WORKER_SLUG}-dev-${SHORT_SHA}"
            DEV_LATEST_TAG="${WORKER_SLUG}-dev-latest"
            {
              echo "tags<<TAGS"
              echo "${IMAGE_REPO}:${DEV_TAG}"
              echo "${IMAGE_REPO}:${DEV_LATEST_TAG}"
              echo "TAGS"
            } >> "$GITHUB_OUTPUT"
            echo "manifest_tag=${DEV_LATEST_TAG}" >> "$GITHUB_OUTPUT"
          fi

      - name: Build and push worker image
        if: steps.check.outputs.should_build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: domains/${{ matrix.worker }}/Dockerfile.worker
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Sync manifest branch
        if: >
          steps.check.outputs.should_build == 'true' &&
          (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
        env:
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          git fetch origin "${BRANCH_NAME}"
          git checkout -B "${BRANCH_NAME}"
          git pull --rebase origin "${BRANCH_NAME}"

      - name: Update worker manifest tag
        if: steps.check.outputs.should_build == 'true'
        id: update_manifest
        env:
          WORKER: ${{ matrix.worker }}
          TAG_NAME: ${{ steps.meta.outputs.manifest_tag }}
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            KUSTOMIZE_FILE="workloads/domains/${WORKER}-worker/prod/kustomization.yaml"
          else
            KUSTOMIZE_FILE="workloads/domains/${WORKER}-worker/dev/kustomization.yaml"
          fi
          
          # kustomization.yamlÏù¥ ÏóÜÏúºÎ©¥ ÏÉùÏÑ±
          if [ ! -f "$KUSTOMIZE_FILE" ]; then
            mkdir -p "$(dirname $KUSTOMIZE_FILE)"
            cat > "$KUSTOMIZE_FILE" << EOF
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization
          resources:
            - ../base
          images:
            - name: docker.io/mng990/eco2
              newTag: ${TAG_NAME}
          EOF
          else
            python -m pip install --upgrade pip pyyaml
            python scripts/ci/update_kustomize_image.py \
              --file "$KUSTOMIZE_FILE" \
              --image docker.io/mng990/eco2 \
              --tag "$TAG_NAME"
          fi
          
          if git diff --quiet -- "$KUSTOMIZE_FILE" 2>/dev/null; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "file=$KUSTOMIZE_FILE" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit worker manifest updates
        if: steps.update_manifest.outputs.changed == 'true'
        env:
          KUSTOMIZE_FILE: ${{ steps.update_manifest.outputs.file }}
          TAG_NAME: ${{ steps.meta.outputs.manifest_tag }}
          WORKER: ${{ matrix.worker }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "${KUSTOMIZE_FILE}"
          git commit -m "chore(${WORKER}-worker): bump image tag to ${TAG_NAME} [skip ci]"
          git push origin HEAD:${GITHUB_REF_NAME}
