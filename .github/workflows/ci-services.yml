name: CI Services Quality Gate

on:
  push:
    branches:
      - main
      - develop
      - refactor/gitops-sync-wave
    paths:
      - "domains/**"
      - "workloads/domains/**"
      - "scripts/**"
      - ".github/workflows/ci-services.yml"
  pull_request:
    branches:
      - main
      - develop
      - refactor/gitops-sync-wave
    paths:
      - "domains/**"
      - "workloads/domains/**"
      - "scripts/**"
      - ".github/workflows/ci-services.yml"
  workflow_dispatch:
    inputs:
      force_all:
        description: "Î™®Îì† API ÏÑúÎπÑÏä§Î•º Í∞ïÏ†úÎ°ú ÎπåÎìú/Ìë∏Ïãú"
        type: boolean
        default: false
      target_services:
        description: "ÏΩ§ÎßàÎ°ú Íµ¨Î∂ÑÎêú ÏÑúÎπÑÏä§ Ïù¥Î¶Ñ Î™©Î°ù (Ïòà: auth,my)"
        required: false

permissions:
  contents: write
  packages: write

concurrency:
  group: ci-services-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  commit-filter:
    name: üõÇ Commit Filter
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.detect.outputs.skip }}
      reason: ${{ steps.detect.outputs.reason }}
      commit_type: ${{ steps.detect.outputs.commit_type }}
    steps:
      - name: Detect conventional commit type
        id: detect
        env:
          EVENT_NAME: ${{ github.event_name }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          set -euo pipefail
          if [ "${GITHUB_ACTOR}" = "github-actions[bot]" ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "reason=Triggered by github-actions bot (manifest bump)" >> "$GITHUB_OUTPUT"
            echo "commit_type=bot" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [ "$EVENT_NAME" = "pull_request" ]; then
            REF_TEXT="$PR_TITLE"
          else
            REF_TEXT="$COMMIT_MSG"
          fi
          REF_TEXT="${REF_TEXT:-none}"
          TYPE=$(printf '%s\n' "$REF_TEXT" | sed -n 's/^\([A-Za-z0-9_-]\+\):.*/\1/p' | tr '[:upper:]' '[:lower:]')
          if [[ "$TYPE" =~ ^(docs)$ ]]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "reason=Commit type '$TYPE' is configured to bypass service CI" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
            echo "reason=" >> "$GITHUB_OUTPUT"
          fi
          if [ -z "$TYPE" ]; then
            TYPE="unknown"
          fi
          echo "commit_type=$TYPE" >> "$GITHUB_OUTPUT"

  skip-notice:
    name: ‚è≠Ô∏è CI Skipped
    needs: commit-filter
    if: needs.commit-filter.outputs.skip == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Publish skip summary
        run: |
          cat <<'EOF' >> "$GITHUB_STEP_SUMMARY"
          ## ‚è≠Ô∏è Service CI Skipped
          - Reason: ${{ needs.commit-filter.outputs.reason }}
          - Commit type: `${{ needs.commit-filter.outputs.commit_type }}`
          EOF

  detect-api-changes:
    name: üîç Detect API Changes
    runs-on: ubuntu-latest
    needs: commit-filter
    if: needs.commit-filter.outputs.skip != 'true'
    outputs:
      has_changes: ${{ steps.prepare.outputs.has_changes }}
      services: ${{ steps.prepare.outputs.services }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Changed files
        id: changes
        uses: tj-actions/changed-files@v45
        with:
          files: |
            domains/**
            workloads/domains/**

      - name: Prepare service matrix
        id: prepare
        run: |
          python3 <<'PYEOF'
          import json
          import os
          import sys
          from collections import OrderedDict

          files = os.environ.get("CHANGED_FILES", "").split()
          any_changed = os.environ.get("ANY_CHANGED", "false").lower() == "true"
          event_name = os.environ.get("EVENT_NAME", "")
          force_all = os.environ.get("FORCE_ALL", "false").lower() == "true"
          alias_map = {
              "info": "image",
          }
          shared_triggers = {
              "domains/_shared/waste_pipeline": ["chat", "scan"],
          }

          def normalize(service: str) -> str:
              return alias_map.get(service, service)

          raw_targets = [
              s.strip()
              for s in os.environ.get("TARGET_SERVICES", "").split(",")
              if s.strip()
          ]
          target_services = [normalize(s) for s in raw_targets]

          services = []
          service_root = "domains"
          discovered = []
          for entry in os.listdir(service_root):
              if entry.startswith("_"):
                  continue
              if not os.path.isdir(os.path.join(service_root, entry)):
                  continue
              discovered.append(normalize(entry))
          all_services = sorted(set(discovered))

          if event_name == "workflow_dispatch":
              if force_all:
                  services = all_services
              elif target_services:
                  invalid = [svc for svc in target_services if svc not in all_services]
                  if invalid:
                      sys.stderr.write(f"Unknown services: {', '.join(invalid)}\n")
                      sys.exit(1)
                  # preserve order
                  services = list(OrderedDict.fromkeys(target_services))

          if not services and any_changed:
              for path in files:
                  # shared Í≤ΩÎ°úÏóê ÎåÄÌïú Ìä∏Î¶¨Í±∞
                  for prefix, svc_list in shared_triggers.items():
                      if path.startswith(prefix):
                          for svc in svc_list:
                              svc = normalize(svc)
                              if svc in all_services and svc not in services:
                                  services.append(svc)
                  
                  # Observability Î≥ÄÍ≤Ω Ïãú Î™®Îì† ÏÑúÎπÑÏä§ Ïû¨Î∞∞Ìè¨
                  if path.startswith("domains/_shared/observability"):
                      services = list(all_services)
                      break

                  parts = path.split("/")
                  # domains/<service>/ Í≤ΩÎ°ú Í∞êÏßÄ
                  if len(parts) >= 2 and parts[0] == "domains":
                      svc = normalize(parts[1])
                      if svc and svc in all_services and svc not in services:
                          services.append(svc)
                  # workloads/domains/<service>/ Í≤ΩÎ°ú Í∞êÏßÄ
                  elif len(parts) >= 3 and parts[0] == "workloads" and parts[1] == "domains":
                      svc = normalize(parts[2])
                      if svc and svc in all_services and svc not in services:
                          services.append(svc)

          with open(os.environ["GITHUB_OUTPUT"], "a") as out:
              if services:
                  out.write("has_changes=true\n")
                  out.write(f"services={json.dumps(services)}\n")
              else:
                  out.write("has_changes=false\n")
                  out.write("services=[]\n")
          PYEOF
        env:
          CHANGED_FILES: ${{ steps.changes.outputs.all_changed_files }}
          ANY_CHANGED: ${{ steps.changes.outputs.any_changed }}
          EVENT_NAME: ${{ github.event_name }}
          FORCE_ALL: ${{ github.event.inputs.force_all || 'false' }}
          TARGET_SERVICES: ${{ github.event.inputs.target_services || '' }}

  api-quality:
    name: üß™ API Lint & Test
    runs-on: ubuntu-latest
    needs:
      - commit-filter
      - detect-api-changes
    if: >
      needs.commit-filter.outputs.skip != 'true' &&
      needs.detect-api-changes.outputs.has_changes == 'true'
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.detect-api-changes.outputs.services) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install tooling
        run: |
          python -m pip install --upgrade pip
          pip install black==24.4.2 ruff==0.6.9 pytest==8.3.3
          pip install -r domains/${{ matrix.service }}/requirements.txt

      - name: Black (format check)
        run: black --check domains/${{ matrix.service }}

      - name: Ruff lint
        run: ruff check domains/${{ matrix.service }}

      - name: Pytest
        working-directory: domains/${{ matrix.service }}
        env:
          PYTHONPATH: ${{ github.workspace }}/domains/${{ matrix.service }}
        run: pytest

  api-build-push:
    name: üì¶ Build & Push API Images
    runs-on: ubuntu-latest
    needs:
      - commit-filter
      - detect-api-changes
      - api-quality
    if: >
      needs.commit-filter.outputs.skip != 'true' &&
      needs.detect-api-changes.outputs.has_changes == 'true'
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        service: ${{ fromJson(needs.detect-api-changes.outputs.services) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Prepare image tags
        id: meta
        run: |
          set -euo pipefail
          SHORT_SHA=$(git rev-parse --short=6 HEAD)
          SERVICE="${{ matrix.service }}"
          IMAGE_REPO="docker.io/mng990/eco2"
          SERVICE_SLUG="${SERVICE}-api"
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            IS_PR=true
            BASE_REF="${{ github.event.pull_request.base.ref }}"
          else
            IS_PR=false
            BASE_REF="${GITHUB_REF##*/}"
          fi
          VERSION=$(cat VERSION)
          if [ "$BASE_REF" = "main" ] && [ "$IS_PR" = "false" ]; then
            UNIQUE_TAG="${SERVICE_SLUG}-${VERSION}-${SHORT_SHA}"
            {
              echo "tags<<TAGS"
              echo "${IMAGE_REPO}:${UNIQUE_TAG}"
              echo "${IMAGE_REPO}:${SERVICE_SLUG}-prod-latest"
              echo "${IMAGE_REPO}:${SERVICE_SLUG}-latest"
              echo "TAGS"
            } >> "$GITHUB_OUTPUT"
            echo "tag_name=${UNIQUE_TAG}" >> "$GITHUB_OUTPUT"
            echo "manifest_tag=${UNIQUE_TAG}" >> "$GITHUB_OUTPUT"
          else
            DEV_TAG="${SERVICE_SLUG}-dev-${SHORT_SHA}"
            DEV_LATEST_TAG="${SERVICE_SLUG}-dev-latest"
            {
              echo "tags<<TAGS"
              echo "${IMAGE_REPO}:${DEV_TAG}"
              echo "${IMAGE_REPO}:${DEV_LATEST_TAG}"
              echo "TAGS"
            } >> "$GITHUB_OUTPUT"
            echo "tag_name=${DEV_TAG}" >> "$GITHUB_OUTPUT"
            echo "manifest_tag=${DEV_LATEST_TAG}" >> "$GITHUB_OUTPUT"
          fi

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: domains/${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Sync manifest branch
        if: >
          (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
        env:
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          git fetch origin "${BRANCH_NAME}"
          git checkout -B "${BRANCH_NAME}"
          git pull --rebase origin "${BRANCH_NAME}"

      - name: Update dev manifest tag
        if: >
          github.ref == 'refs/heads/develop'
        id: update_dev
        env:
          KUSTOMIZE_FILE: workloads/domains/${{ matrix.service }}/dev/kustomization.yaml
          TAG_NAME: ${{ steps.meta.outputs.manifest_tag }}
        run: |
          python -m pip install --upgrade pip pyyaml
          python scripts/ci/update_kustomize_image.py \
            --file "$KUSTOMIZE_FILE" \
            --image docker.io/mng990/eco2 \
            --tag "$TAG_NAME"
          if git diff --quiet -- "$KUSTOMIZE_FILE"; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "file=$KUSTOMIZE_FILE" >> "$GITHUB_OUTPUT"
          fi

      - name: Update prod manifest tag
        if: >
          github.ref == 'refs/heads/main'
        id: update_prod
        env:
          KUSTOMIZE_FILE: workloads/domains/${{ matrix.service }}/prod/kustomization.yaml
          TAG_NAME: ${{ steps.meta.outputs.tag_name }}
        run: |
          python -m pip install --upgrade pip pyyaml
          python scripts/ci/update_kustomize_image.py \
            --file "$KUSTOMIZE_FILE" \
            --image docker.io/mng990/eco2 \
            --tag "$TAG_NAME"
          if git diff --quiet -- "$KUSTOMIZE_FILE"; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "file=$KUSTOMIZE_FILE" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit manifest updates
        if: >
          (steps.update_dev.outputs.changed == 'true') ||
          (steps.update_prod.outputs.changed == 'true')
        env:
          DEV_FILE: ${{ steps.update_dev.outputs.file }}
          PROD_FILE: ${{ steps.update_prod.outputs.file }}
          TAG_NAME: ${{ steps.meta.outputs.manifest_tag }}
          SERVICE: ${{ matrix.service }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if [ -n "${DEV_FILE}" ]; then git add "${DEV_FILE}"; fi
          if [ -n "${PROD_FILE}" ]; then git add "${PROD_FILE}"; fi
          git commit -m "chore(${SERVICE}): bump image tag to ${TAG_NAME} [skip ci]"
          git push origin HEAD:${GITHUB_REF_NAME}


